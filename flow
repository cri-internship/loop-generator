def flow_dependency(dest_array_name, source_array_name, optimize, extra):
    arr_name = dest_array_name.partition('[')[0]
    arr_def = (arr_name, all_arrays[arr_name])
    if extra == 'random':
        result = gen_random_part(dest_array_name, source_array_name, optimize, arr_def)
    else:
        result = gen_scalar_part(dest_array_name, source_array_name, optimize)
    return result


def gen_random_part(dest_array_name, source_array_name, optimize, arr_def):
    if optimize:
        source = f'{source_array_name}{gen_calc_for_read(random.choice(rand_num_of_calculations), arr_def)}'
        result = gen_one_stmt(dest_array_name, source)
    else:
        stmt_body = {}
        stmt_body['destination'] = [dest_array_name,
                                    f'{gen_random_stmt(unique_arrays_write)}']
        stmt_body['source'] = [f'{gen_calc_for_read(random.choice(rand_num_of_calculations), arr_def)[1:]},
                                f'{source_array_name}{gen_calc_for_read(random.choice(rand_num_of_calculations), arr_def)}]
        result = gen_full_stmt(dest_array_name, source, source1, destination1)
    return result


def gen_scalar_part(dest_array_name, source_array_name, optimize):
    if optimize:
        source = f'{source_array_name}{random.choice(maths_operations)}{round(random.random(), 5)}'
        result = gen_one_stmt(dest_array_name, source)
    else:
    stmt_body = {}
        stmt_body['destination'] = [dest_array_name, f'{generate_var("float ")}']
        stmt_body['source'] = [f'{round(random.random(), 5)},
                               f'{source_array_name}{random.choice(maths_operations)}{round(random.random(), 5)}']
        result = gen_full_stmt(dest_array_name, stmt_body) #source, source1, destination1)
    return result

def gen_based_on_usage_flow(destination, stmt_body):
    array = destination #stmt_body['destination'][0]
    if satisfies_flow(array):
            dest_usage = literal_values_destination[array][1]
            source_usage = literal_values_source[array][1]
            if dest_usage < source_usage:
                result = ""
    elif destination in literal_values_destination.keys():
        result = gen_one_line_flow(stmt_body, 0)
    else:
        result = gen_full_stmt_flow(stmt_body)
    return result

def satisfies_flow(array):
    return array in literal_values_destination.keys() and array in literal_values_source.keys()

def gen_one_line_flow(stmt_body, element):
    destination = stmt_body['destination'][element]
    source = stmt_body['destination'][element]
    populate_values(destination, source)
    inc_stmt_counter()
    result += '\n' + destination + '=' + source
    return result

def gen_full_stmt_flow(stmt_body):
    result = gen_one_line_flow(stmt_body,0) + ';\n'
    result += gen_one_line_flow(stmt_body,1)
    return result
